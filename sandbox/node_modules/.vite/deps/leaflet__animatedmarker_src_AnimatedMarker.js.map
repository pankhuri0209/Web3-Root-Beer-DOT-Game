{
  "version": 3,
  "sources": ["../../leaflet.animatedmarker/src/AnimatedMarker.js"],
  "sourcesContent": ["L.AnimatedMarker = L.Marker.extend({\n  options: {\n    // meters\n    distance: 200,\n    // ms\n    interval: 1000,\n    // animate on add?\n    autoStart: true,\n    // callback onend\n    onEnd: function(){},\n    clickable: false\n  },\n\n  initialize: function (latlngs, options) {\n    this.setLine(latlngs);\n    L.Marker.prototype.initialize.call(this, latlngs[0], options);\n  },\n\n  // Breaks the line up into tiny chunks (see options) ONLY if CSS3 animations\n  // are not supported.\n  _chunk: function(latlngs) {\n    var i,\n        len = latlngs.length,\n        chunkedLatLngs = [];\n\n    for (i=1;i<len;i++) {\n      var cur = latlngs[i-1],\n          next = latlngs[i],\n          dist = cur.distanceTo(next),\n          factor = this.options.distance / dist,\n          dLat = factor * (next.lat - cur.lat),\n          dLng = factor * (next.lng - cur.lng);\n\n      if (dist > this.options.distance) {\n        while (dist > this.options.distance) {\n          cur = new L.LatLng(cur.lat + dLat, cur.lng + dLng);\n          dist = cur.distanceTo(next);\n          chunkedLatLngs.push(cur);\n        }\n      } else {\n        chunkedLatLngs.push(cur);\n      }\n    }\n    chunkedLatLngs.push(latlngs[len-1]);\n\n    return chunkedLatLngs;\n  },\n\n  onAdd: function (map) {\n    L.Marker.prototype.onAdd.call(this, map);\n\n    // Start animating when added to the map\n    if (this.options.autoStart) {\n      this.start();\n    }\n  },\n\n  animate: function() {\n    var self = this,\n        len = this._latlngs.length,\n        speed = this.options.interval;\n\n    // Normalize the transition speed from vertex to vertex\n    if (this._i < len && this.i > 0) {\n      speed = this._latlngs[this._i-1].distanceTo(this._latlngs[this._i]) / this.options.distance * this.options.interval;\n    }\n\n    // Only if CSS3 transitions are supported\n    if (L.DomUtil.TRANSITION) {\n      if (this._icon) { this._icon.style[L.DomUtil.TRANSITION] = ('all ' + speed + 'ms linear'); }\n      if (this._shadow) { this._shadow.style[L.DomUtil.TRANSITION] = 'all ' + speed + 'ms linear'; }\n    }\n\n    // Move to the next vertex\n    this.setLatLng(this._latlngs[this._i]);\n    this._i++;\n\n    // Queue up the animation to the next next vertex\n    this._tid = setTimeout(function(){\n      if (self._i === len) {\n        self.options.onEnd.apply(self, Array.prototype.slice.call(arguments));\n      } else {\n        self.animate();\n      }\n    }, speed);\n  },\n\n  // Start the animation\n  start: function() {\n    this.animate();\n  },\n\n  // Stop the animation in place\n  stop: function() {\n    if (this._tid) {\n      clearTimeout(this._tid);\n    }\n  },\n\n  setLine: function(latlngs){\n    if (L.DomUtil.TRANSITION) {\n      // No need to to check up the line if we can animate using CSS3\n      this._latlngs = latlngs;\n    } else {\n      // Chunk up the lines into options.distance bits\n      this._latlngs = this._chunk(latlngs);\n      this.options.distance = 10;\n      this.options.interval = 30;\n    }\n    this._i = 0;\n  }\n\n});\n\nL.animatedMarker = function (latlngs, options) {\n  return new L.AnimatedMarker(latlngs, options);\n};\n"],
  "mappings": "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",
  "names": []
}
